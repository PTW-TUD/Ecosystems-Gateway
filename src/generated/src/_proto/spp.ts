// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v3.20.3
// source: src/_proto/spp.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Struct } from "../../google/protobuf/struct";

export const protobufPackage = "eupg.serviceofferingpublisher";

/** Possible lifecycle states of asset */
export enum LifecycleStates {
  /**
   * ACTIVE - Fully functional asset
   * Discoverable in Portal and Ordering allowed
   * Listed under the owner's profile
   */
  ACTIVE = 0,
  /**
   * END_OF_LIFE - This state indicates that the asset is usually deprecated or outdated
   * Discoverable, but not orderable
   * Not listed under the owner's profile
   */
  END_OF_LIFE = 1,
  /**
   * DEPRECATED - This state indicates that another asset has deprecated the current asset
   * Not discoverable and not orderable
   * Not listed under the owner's profile
   */
  DEPRECATED = 2,
  /**
   * REVOKED_BY_PUBLISHER - Publisher has explicitly revoked access or ownership rights to the asset
   * Not discoverable and not orderable
   */
  REVOKED_BY_PUBLISHER = 3,
  /**
   * ORDERING_DISABLED_TEMPORARILY - Users can view the asset and gather information, but they cannot place orders at that moment
   * Discoverable, but not orderable
   * Listed under the owner's profile.
   */
  ORDERING_DISABLED_TEMPORARILY = 4,
  /**
   * ASSET_UNLISTED - Not discoverable, but orderable
   * Listed under the owner's profile
   */
  ASSET_UNLISTED = 5,
  UNRECOGNIZED = -1,
}

export function lifecycleStatesFromJSON(object: any): LifecycleStates {
  switch (object) {
    case 0:
    case "ACTIVE":
      return LifecycleStates.ACTIVE;
    case 1:
    case "END_OF_LIFE":
      return LifecycleStates.END_OF_LIFE;
    case 2:
    case "DEPRECATED":
      return LifecycleStates.DEPRECATED;
    case 3:
    case "REVOKED_BY_PUBLISHER":
      return LifecycleStates.REVOKED_BY_PUBLISHER;
    case 4:
    case "ORDERING_DISABLED_TEMPORARILY":
      return LifecycleStates.ORDERING_DISABLED_TEMPORARILY;
    case 5:
    case "ASSET_UNLISTED":
      return LifecycleStates.ASSET_UNLISTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LifecycleStates.UNRECOGNIZED;
  }
}

export function lifecycleStatesToJSON(object: LifecycleStates): string {
  switch (object) {
    case LifecycleStates.ACTIVE:
      return "ACTIVE";
    case LifecycleStates.END_OF_LIFE:
      return "END_OF_LIFE";
    case LifecycleStates.DEPRECATED:
      return "DEPRECATED";
    case LifecycleStates.REVOKED_BY_PUBLISHER:
      return "REVOKED_BY_PUBLISHER";
    case LifecycleStates.ORDERING_DISABLED_TEMPORARILY:
      return "ORDERING_DISABLED_TEMPORARILY";
    case LifecycleStates.ASSET_UNLISTED:
      return "ASSET_UNLISTED";
    case LifecycleStates.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Create message to publish a Offering with the given information
 * At the moment: Primarily tailored for ocean market (and for datasets)
 */
export interface CreateOfferingRequest {
  /** The main information about the asset to publish */
  main:
    | Main
    | undefined;
  /** Additional information regarding the offering */
  additionalInformation:
    | AdditionalInformation
    | undefined;
  /**
   * Symbol (Abbreviation) for the access token that is generated for consuming the asset
   * Important for following access token transactions in the explorer
   */
  token: string;
  /** Name of the offering which is also used for the token name */
  name: string;
}

/** Update message for an already published Offering */
export interface UpdateOfferingRequest {
  /**
   * Decentralised identifier for the already published offering
   * example: did:op:1234
   */
  did: string;
  main?: Main | undefined;
  additionalInformation?: AdditionalInformation | undefined;
  token?: string | undefined;
  name?:
    | string
    | undefined;
  /**
   * Optional information about the published asset
   * If this Information is set, it is used to publish the offering to the Credential Event Service
   */
  publishInfo?:
    | PublishInfo
    | undefined;
  /**
   * Optional indices of the services of the asset that are to be updated
   * If no index is given all services are edited
   */
  index: number[];
}

/** Update message for changing the LifecycleState of an already published offering */
export interface UpdateOfferingLifecycleRequest {
  did: string;
  to: LifecycleStates;
}

/**
 * Publish info used in UpdateOfferingRequest
 * Used for additionally publishing Offering to Credential Event Service
 */
export interface PublishInfo {
  /**
   * The source where to find the published offering
   * example: https://www.pontus-x.eu/asset/did:op:ac74139fa102d32f326ccdab3727a95299f1c2b6add9158385439e5b06810833
   */
  source: string;
  /**
   * The data that is submitted to the credential event service
   * At the moment: Has to be a (Compliance) VC issued by the Gaia-X compliance engine
   */
  data: string;
}

/** Main metadata information for the asset used in CreateOfferingRequest and UpdateOfferingRequest */
export interface Main {
  /**
   * type of the asset
   * Can be either 'dataset' or 'algorithm'
   */
  type: string;
  /** Name of the entity generating this data */
  author: string;
  /**
   * Short name referencing the license of the asset
   * example: CC-BY, Public Domain
   */
  licence: string;
  /**
   * !UNUSED!
   * ISO 8601 format preferably with timezone identifiers
   * example: 2000-10-31T01:30:00Z
   */
  dateCreated?:
    | string
    | undefined;
  /**
   * Files that contain the data related to the asset
   * At least one file is required
   */
  files: Files[];
  /** Optional keywords or tags used to describe the content of the offering */
  tags: string[];
  /**
   * Details of what the resource is. For a dataset, this attribute explains what the data represents and what it can be used for.
   * This information is displayed in the portal
   * Supports markdown
   */
  description: string;
  /**
   * Optional whitelisted Algorithms than can be used on the asset
   * Only usable if the offering is of type 'compute' and not 'access' (At the moment default='compute')
   */
  allowedAlgorithm: Algorithm[];
}

/** Additional information about the asset used in CreateOfferingRequest and UpdateOfferingRequest */
export interface AdditionalInformation {
  /** !UNUSED! */
  description: string;
  /** !UNUSED! */
  serviceSelfDescription:
    | ServiceSelfDescription
    | undefined;
  /** Boolean to indicate if the publisher specifies it's own terms and conditions for consumption of the asset */
  termsAndConditions: boolean;
  /** Information in the context of Gaia-X compliance including the link to the Self-Description of the offering (VP) */
  gaiaXInformation: gaiaX | undefined;
}

/**
 * Information about a file related to a offering used in Main
 * At the moment only files that are accessible over a Static URL (HTTP) are accepted
 * (possible alternatives: Arweave, GraphQL, IPFS, Smart Contract)
 */
export interface Files {
  /** File URL */
  url: string;
  /** !UNUSED! */
  indest: number;
  /** !UNUSED! */
  contentType: string;
  /**
   * HTTP Method used to access the file
   * example: 'GET'
   */
  method: string;
  /** Optional file index */
  index?: number | undefined;
}

/** Algorithm that is allowed/trusted by the publisher to be used on asset used in Main */
export interface Algorithm {
  /**
   * Decentralised identifier of the already published algorithm
   * example did:op:456
   */
  did: string;
  /**
   * Hash of trusted algorithm's files
   * Can be created over Ocean Provider FileInfoEndpoint with parameter withChecksum = True
   * If the algorithm has multiple files, filesChecksum is a concatenated string of all files checksums
   */
  filesChecksum: string;
  /**
   * Hash of algorithm's image details (entrypoint and image checksum)
   * Produced by: sha256(algorithm_ddo.metadata.algorithm.container.entrypoint + algorithm_ddo.metadata.algorithm.container.checksum)
   */
  containerSectionChecksum: string;
}

/** Information related to Gaia-X compliance used in AdditionalInformation */
export interface gaiaX {
  /** Identifier if the asset contains personally identifiable information */
  containsPII: boolean;
  /** Terms and conditions additionally set by the publisher of the asset */
  termsAndConditions: Terms[];
  /** Gaia-X compliant Self-Description of the offering */
  serviceSD: ServiceSelfDescription | undefined;
}

/** Enpoint to the VP of the offering used in gaiaX */
export interface ServiceSelfDescription {
  /** Static URL of the self-description */
  url: string;
  /**
   * Optional identifier if the self-description has been verified against a Gaia-X Compliance Service
   * Mainly used by the deltaDAO portal
   */
  isVerified?: boolean | undefined;
}

/** Static URL to Terms and Conditions defined by the publisher of the asset used in gaiaX */
export interface Terms {
  url: string;
}

/** Response to CreateOfferingRequest */
export interface CreateOfferingResponse {
  /**
   * did of the successfully published offering
   * example: did:op:123
   */
  did: string;
  /** Debug information */
  DebugInformation: { [key: string]: any } | undefined;
}

/** Response to UpdateOfferingRequest */
export interface UpdateOfferingResponse {
  location?: string | undefined;
  DebugInformation: { [key: string]: any } | undefined;
}

export interface UpdateOfferingLifecycleResponse {
  DebugInformation: { [key: string]: any } | undefined;
}

export interface CreateComputeToDataRequest {
  did: string;
  algorithm: string;
}

export interface ComputeToDataResponse {
  jobId: string[];
}

export interface GetOfferingRequest {
  did: string;
}

export interface GetOfferingResponse {
  did: string;
}

function createBaseCreateOfferingRequest(): CreateOfferingRequest {
  return { main: undefined, additionalInformation: undefined, token: "", name: "" };
}

export const CreateOfferingRequest = {
  encode(message: CreateOfferingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.main !== undefined) {
      Main.encode(message.main, writer.uint32(18).fork()).ldelim();
    }
    if (message.additionalInformation !== undefined) {
      AdditionalInformation.encode(message.additionalInformation, writer.uint32(26).fork()).ldelim();
    }
    if (message.token !== "") {
      writer.uint32(34).string(message.token);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOfferingRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOfferingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.main = Main.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.additionalInformation = AdditionalInformation.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.token = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOfferingRequest {
    return {
      main: isSet(object.main) ? Main.fromJSON(object.main) : undefined,
      additionalInformation: isSet(object.additionalInformation)
        ? AdditionalInformation.fromJSON(object.additionalInformation)
        : undefined,
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: CreateOfferingRequest): unknown {
    const obj: any = {};
    if (message.main !== undefined) {
      obj.main = Main.toJSON(message.main);
    }
    if (message.additionalInformation !== undefined) {
      obj.additionalInformation = AdditionalInformation.toJSON(message.additionalInformation);
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateOfferingRequest>, I>>(base?: I): CreateOfferingRequest {
    return CreateOfferingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateOfferingRequest>, I>>(object: I): CreateOfferingRequest {
    const message = createBaseCreateOfferingRequest();
    message.main = (object.main !== undefined && object.main !== null) ? Main.fromPartial(object.main) : undefined;
    message.additionalInformation =
      (object.additionalInformation !== undefined && object.additionalInformation !== null)
        ? AdditionalInformation.fromPartial(object.additionalInformation)
        : undefined;
    message.token = object.token ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateOfferingRequest(): UpdateOfferingRequest {
  return {
    did: "",
    main: undefined,
    additionalInformation: undefined,
    token: undefined,
    name: undefined,
    publishInfo: undefined,
    index: [],
  };
}

export const UpdateOfferingRequest = {
  encode(message: UpdateOfferingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.did !== "") {
      writer.uint32(10).string(message.did);
    }
    if (message.main !== undefined) {
      Main.encode(message.main, writer.uint32(18).fork()).ldelim();
    }
    if (message.additionalInformation !== undefined) {
      AdditionalInformation.encode(message.additionalInformation, writer.uint32(26).fork()).ldelim();
    }
    if (message.token !== undefined) {
      writer.uint32(34).string(message.token);
    }
    if (message.name !== undefined) {
      writer.uint32(42).string(message.name);
    }
    if (message.publishInfo !== undefined) {
      PublishInfo.encode(message.publishInfo, writer.uint32(50).fork()).ldelim();
    }
    writer.uint32(58).fork();
    for (const v of message.index) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateOfferingRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOfferingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.did = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.main = Main.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.additionalInformation = AdditionalInformation.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.token = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.publishInfo = PublishInfo.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag === 56) {
            message.index.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.index.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOfferingRequest {
    return {
      did: isSet(object.did) ? globalThis.String(object.did) : "",
      main: isSet(object.main) ? Main.fromJSON(object.main) : undefined,
      additionalInformation: isSet(object.additionalInformation)
        ? AdditionalInformation.fromJSON(object.additionalInformation)
        : undefined,
      token: isSet(object.token) ? globalThis.String(object.token) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      publishInfo: isSet(object.publishInfo) ? PublishInfo.fromJSON(object.publishInfo) : undefined,
      index: globalThis.Array.isArray(object?.index) ? object.index.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: UpdateOfferingRequest): unknown {
    const obj: any = {};
    if (message.did !== "") {
      obj.did = message.did;
    }
    if (message.main !== undefined) {
      obj.main = Main.toJSON(message.main);
    }
    if (message.additionalInformation !== undefined) {
      obj.additionalInformation = AdditionalInformation.toJSON(message.additionalInformation);
    }
    if (message.token !== undefined) {
      obj.token = message.token;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.publishInfo !== undefined) {
      obj.publishInfo = PublishInfo.toJSON(message.publishInfo);
    }
    if (message.index?.length) {
      obj.index = message.index.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOfferingRequest>, I>>(base?: I): UpdateOfferingRequest {
    return UpdateOfferingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateOfferingRequest>, I>>(object: I): UpdateOfferingRequest {
    const message = createBaseUpdateOfferingRequest();
    message.did = object.did ?? "";
    message.main = (object.main !== undefined && object.main !== null) ? Main.fromPartial(object.main) : undefined;
    message.additionalInformation =
      (object.additionalInformation !== undefined && object.additionalInformation !== null)
        ? AdditionalInformation.fromPartial(object.additionalInformation)
        : undefined;
    message.token = object.token ?? undefined;
    message.name = object.name ?? undefined;
    message.publishInfo = (object.publishInfo !== undefined && object.publishInfo !== null)
      ? PublishInfo.fromPartial(object.publishInfo)
      : undefined;
    message.index = object.index?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateOfferingLifecycleRequest(): UpdateOfferingLifecycleRequest {
  return { did: "", to: 0 };
}

export const UpdateOfferingLifecycleRequest = {
  encode(message: UpdateOfferingLifecycleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.did !== "") {
      writer.uint32(10).string(message.did);
    }
    if (message.to !== 0) {
      writer.uint32(16).int32(message.to);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateOfferingLifecycleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOfferingLifecycleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.did = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.to = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOfferingLifecycleRequest {
    return {
      did: isSet(object.did) ? globalThis.String(object.did) : "",
      to: isSet(object.to) ? lifecycleStatesFromJSON(object.to) : 0,
    };
  },

  toJSON(message: UpdateOfferingLifecycleRequest): unknown {
    const obj: any = {};
    if (message.did !== "") {
      obj.did = message.did;
    }
    if (message.to !== 0) {
      obj.to = lifecycleStatesToJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOfferingLifecycleRequest>, I>>(base?: I): UpdateOfferingLifecycleRequest {
    return UpdateOfferingLifecycleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateOfferingLifecycleRequest>, I>>(
    object: I,
  ): UpdateOfferingLifecycleRequest {
    const message = createBaseUpdateOfferingLifecycleRequest();
    message.did = object.did ?? "";
    message.to = object.to ?? 0;
    return message;
  },
};

function createBasePublishInfo(): PublishInfo {
  return { source: "", data: "" };
}

export const PublishInfo = {
  encode(message: PublishInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.data !== "") {
      writer.uint32(18).string(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublishInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishInfo {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
    };
  },

  toJSON(message: PublishInfo): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishInfo>, I>>(base?: I): PublishInfo {
    return PublishInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishInfo>, I>>(object: I): PublishInfo {
    const message = createBasePublishInfo();
    message.source = object.source ?? "";
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseMain(): Main {
  return {
    type: "",
    author: "",
    licence: "",
    dateCreated: undefined,
    files: [],
    tags: [],
    description: "",
    allowedAlgorithm: [],
  };
}

export const Main = {
  encode(message: Main, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.author !== "") {
      writer.uint32(26).string(message.author);
    }
    if (message.licence !== "") {
      writer.uint32(34).string(message.licence);
    }
    if (message.dateCreated !== undefined) {
      writer.uint32(42).string(message.dateCreated);
    }
    for (const v of message.files) {
      Files.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.tags) {
      writer.uint32(58).string(v!);
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    for (const v of message.allowedAlgorithm) {
      Algorithm.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Main {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.author = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.licence = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dateCreated = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.files.push(Files.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.allowedAlgorithm.push(Algorithm.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Main {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      author: isSet(object.author) ? globalThis.String(object.author) : "",
      licence: isSet(object.licence) ? globalThis.String(object.licence) : "",
      dateCreated: isSet(object.dateCreated) ? globalThis.String(object.dateCreated) : undefined,
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => Files.fromJSON(e)) : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      allowedAlgorithm: globalThis.Array.isArray(object?.allowedAlgorithm)
        ? object.allowedAlgorithm.map((e: any) => Algorithm.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Main): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.author !== "") {
      obj.author = message.author;
    }
    if (message.licence !== "") {
      obj.licence = message.licence;
    }
    if (message.dateCreated !== undefined) {
      obj.dateCreated = message.dateCreated;
    }
    if (message.files?.length) {
      obj.files = message.files.map((e) => Files.toJSON(e));
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.allowedAlgorithm?.length) {
      obj.allowedAlgorithm = message.allowedAlgorithm.map((e) => Algorithm.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Main>, I>>(base?: I): Main {
    return Main.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Main>, I>>(object: I): Main {
    const message = createBaseMain();
    message.type = object.type ?? "";
    message.author = object.author ?? "";
    message.licence = object.licence ?? "";
    message.dateCreated = object.dateCreated ?? undefined;
    message.files = object.files?.map((e) => Files.fromPartial(e)) || [];
    message.tags = object.tags?.map((e) => e) || [];
    message.description = object.description ?? "";
    message.allowedAlgorithm = object.allowedAlgorithm?.map((e) => Algorithm.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAdditionalInformation(): AdditionalInformation {
  return { description: "", serviceSelfDescription: undefined, termsAndConditions: false, gaiaXInformation: undefined };
}

export const AdditionalInformation = {
  encode(message: AdditionalInformation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.serviceSelfDescription !== undefined) {
      ServiceSelfDescription.encode(message.serviceSelfDescription, writer.uint32(26).fork()).ldelim();
    }
    if (message.termsAndConditions !== false) {
      writer.uint32(32).bool(message.termsAndConditions);
    }
    if (message.gaiaXInformation !== undefined) {
      gaiaX.encode(message.gaiaXInformation, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AdditionalInformation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdditionalInformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.serviceSelfDescription = ServiceSelfDescription.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.termsAndConditions = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gaiaXInformation = gaiaX.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdditionalInformation {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      serviceSelfDescription: isSet(object.serviceSelfDescription)
        ? ServiceSelfDescription.fromJSON(object.serviceSelfDescription)
        : undefined,
      termsAndConditions: isSet(object.termsAndConditions) ? globalThis.Boolean(object.termsAndConditions) : false,
      gaiaXInformation: isSet(object.gaiaXInformation) ? gaiaX.fromJSON(object.gaiaXInformation) : undefined,
    };
  },

  toJSON(message: AdditionalInformation): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.serviceSelfDescription !== undefined) {
      obj.serviceSelfDescription = ServiceSelfDescription.toJSON(message.serviceSelfDescription);
    }
    if (message.termsAndConditions !== false) {
      obj.termsAndConditions = message.termsAndConditions;
    }
    if (message.gaiaXInformation !== undefined) {
      obj.gaiaXInformation = gaiaX.toJSON(message.gaiaXInformation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdditionalInformation>, I>>(base?: I): AdditionalInformation {
    return AdditionalInformation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdditionalInformation>, I>>(object: I): AdditionalInformation {
    const message = createBaseAdditionalInformation();
    message.description = object.description ?? "";
    message.serviceSelfDescription =
      (object.serviceSelfDescription !== undefined && object.serviceSelfDescription !== null)
        ? ServiceSelfDescription.fromPartial(object.serviceSelfDescription)
        : undefined;
    message.termsAndConditions = object.termsAndConditions ?? false;
    message.gaiaXInformation = (object.gaiaXInformation !== undefined && object.gaiaXInformation !== null)
      ? gaiaX.fromPartial(object.gaiaXInformation)
      : undefined;
    return message;
  },
};

function createBaseFiles(): Files {
  return { url: "", indest: 0, contentType: "", method: "", index: undefined };
}

export const Files = {
  encode(message: Files, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.indest !== 0) {
      writer.uint32(16).int32(message.indest);
    }
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    if (message.method !== "") {
      writer.uint32(34).string(message.method);
    }
    if (message.index !== undefined) {
      writer.uint32(40).int32(message.index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Files {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFiles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.indest = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.method = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.index = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Files {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      indest: isSet(object.indest) ? globalThis.Number(object.indest) : 0,
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : undefined,
    };
  },

  toJSON(message: Files): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.indest !== 0) {
      obj.indest = Math.round(message.indest);
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.index !== undefined) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Files>, I>>(base?: I): Files {
    return Files.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Files>, I>>(object: I): Files {
    const message = createBaseFiles();
    message.url = object.url ?? "";
    message.indest = object.indest ?? 0;
    message.contentType = object.contentType ?? "";
    message.method = object.method ?? "";
    message.index = object.index ?? undefined;
    return message;
  },
};

function createBaseAlgorithm(): Algorithm {
  return { did: "", filesChecksum: "", containerSectionChecksum: "" };
}

export const Algorithm = {
  encode(message: Algorithm, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.did !== "") {
      writer.uint32(10).string(message.did);
    }
    if (message.filesChecksum !== "") {
      writer.uint32(18).string(message.filesChecksum);
    }
    if (message.containerSectionChecksum !== "") {
      writer.uint32(26).string(message.containerSectionChecksum);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Algorithm {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.did = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filesChecksum = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.containerSectionChecksum = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Algorithm {
    return {
      did: isSet(object.did) ? globalThis.String(object.did) : "",
      filesChecksum: isSet(object.filesChecksum) ? globalThis.String(object.filesChecksum) : "",
      containerSectionChecksum: isSet(object.containerSectionChecksum)
        ? globalThis.String(object.containerSectionChecksum)
        : "",
    };
  },

  toJSON(message: Algorithm): unknown {
    const obj: any = {};
    if (message.did !== "") {
      obj.did = message.did;
    }
    if (message.filesChecksum !== "") {
      obj.filesChecksum = message.filesChecksum;
    }
    if (message.containerSectionChecksum !== "") {
      obj.containerSectionChecksum = message.containerSectionChecksum;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Algorithm>, I>>(base?: I): Algorithm {
    return Algorithm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Algorithm>, I>>(object: I): Algorithm {
    const message = createBaseAlgorithm();
    message.did = object.did ?? "";
    message.filesChecksum = object.filesChecksum ?? "";
    message.containerSectionChecksum = object.containerSectionChecksum ?? "";
    return message;
  },
};

function createBasegaiaX(): gaiaX {
  return { containsPII: false, termsAndConditions: [], serviceSD: undefined };
}

export const gaiaX = {
  encode(message: gaiaX, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.containsPII !== false) {
      writer.uint32(8).bool(message.containsPII);
    }
    for (const v of message.termsAndConditions) {
      Terms.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.serviceSD !== undefined) {
      ServiceSelfDescription.encode(message.serviceSD, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): gaiaX {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasegaiaX();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.containsPII = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.termsAndConditions.push(Terms.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.serviceSD = ServiceSelfDescription.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): gaiaX {
    return {
      containsPII: isSet(object.containsPII) ? globalThis.Boolean(object.containsPII) : false,
      termsAndConditions: globalThis.Array.isArray(object?.termsAndConditions)
        ? object.termsAndConditions.map((e: any) => Terms.fromJSON(e))
        : [],
      serviceSD: isSet(object.serviceSD) ? ServiceSelfDescription.fromJSON(object.serviceSD) : undefined,
    };
  },

  toJSON(message: gaiaX): unknown {
    const obj: any = {};
    if (message.containsPII !== false) {
      obj.containsPII = message.containsPII;
    }
    if (message.termsAndConditions?.length) {
      obj.termsAndConditions = message.termsAndConditions.map((e) => Terms.toJSON(e));
    }
    if (message.serviceSD !== undefined) {
      obj.serviceSD = ServiceSelfDescription.toJSON(message.serviceSD);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<gaiaX>, I>>(base?: I): gaiaX {
    return gaiaX.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<gaiaX>, I>>(object: I): gaiaX {
    const message = createBasegaiaX();
    message.containsPII = object.containsPII ?? false;
    message.termsAndConditions = object.termsAndConditions?.map((e) => Terms.fromPartial(e)) || [];
    message.serviceSD = (object.serviceSD !== undefined && object.serviceSD !== null)
      ? ServiceSelfDescription.fromPartial(object.serviceSD)
      : undefined;
    return message;
  },
};

function createBaseServiceSelfDescription(): ServiceSelfDescription {
  return { url: "", isVerified: undefined };
}

export const ServiceSelfDescription = {
  encode(message: ServiceSelfDescription, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.isVerified !== undefined) {
      writer.uint32(16).bool(message.isVerified);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServiceSelfDescription {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceSelfDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isVerified = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceSelfDescription {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      isVerified: isSet(object.isVerified) ? globalThis.Boolean(object.isVerified) : undefined,
    };
  },

  toJSON(message: ServiceSelfDescription): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.isVerified !== undefined) {
      obj.isVerified = message.isVerified;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceSelfDescription>, I>>(base?: I): ServiceSelfDescription {
    return ServiceSelfDescription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceSelfDescription>, I>>(object: I): ServiceSelfDescription {
    const message = createBaseServiceSelfDescription();
    message.url = object.url ?? "";
    message.isVerified = object.isVerified ?? undefined;
    return message;
  },
};

function createBaseTerms(): Terms {
  return { url: "" };
}

export const Terms = {
  encode(message: Terms, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Terms {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTerms();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Terms {
    return { url: isSet(object.url) ? globalThis.String(object.url) : "" };
  },

  toJSON(message: Terms): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Terms>, I>>(base?: I): Terms {
    return Terms.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Terms>, I>>(object: I): Terms {
    const message = createBaseTerms();
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseCreateOfferingResponse(): CreateOfferingResponse {
  return { did: "", DebugInformation: undefined };
}

export const CreateOfferingResponse = {
  encode(message: CreateOfferingResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.did !== "") {
      writer.uint32(10).string(message.did);
    }
    if (message.DebugInformation !== undefined) {
      Struct.encode(Struct.wrap(message.DebugInformation), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOfferingResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOfferingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.did = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.DebugInformation = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOfferingResponse {
    return {
      did: isSet(object.did) ? globalThis.String(object.did) : "",
      DebugInformation: isObject(object.DebugInformation) ? object.DebugInformation : undefined,
    };
  },

  toJSON(message: CreateOfferingResponse): unknown {
    const obj: any = {};
    if (message.did !== "") {
      obj.did = message.did;
    }
    if (message.DebugInformation !== undefined) {
      obj.DebugInformation = message.DebugInformation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateOfferingResponse>, I>>(base?: I): CreateOfferingResponse {
    return CreateOfferingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateOfferingResponse>, I>>(object: I): CreateOfferingResponse {
    const message = createBaseCreateOfferingResponse();
    message.did = object.did ?? "";
    message.DebugInformation = object.DebugInformation ?? undefined;
    return message;
  },
};

function createBaseUpdateOfferingResponse(): UpdateOfferingResponse {
  return { location: undefined, DebugInformation: undefined };
}

export const UpdateOfferingResponse = {
  encode(message: UpdateOfferingResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.location !== undefined) {
      writer.uint32(34).string(message.location);
    }
    if (message.DebugInformation !== undefined) {
      Struct.encode(Struct.wrap(message.DebugInformation), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateOfferingResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOfferingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.location = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.DebugInformation = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOfferingResponse {
    return {
      location: isSet(object.location) ? globalThis.String(object.location) : undefined,
      DebugInformation: isObject(object.DebugInformation) ? object.DebugInformation : undefined,
    };
  },

  toJSON(message: UpdateOfferingResponse): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = message.location;
    }
    if (message.DebugInformation !== undefined) {
      obj.DebugInformation = message.DebugInformation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOfferingResponse>, I>>(base?: I): UpdateOfferingResponse {
    return UpdateOfferingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateOfferingResponse>, I>>(object: I): UpdateOfferingResponse {
    const message = createBaseUpdateOfferingResponse();
    message.location = object.location ?? undefined;
    message.DebugInformation = object.DebugInformation ?? undefined;
    return message;
  },
};

function createBaseUpdateOfferingLifecycleResponse(): UpdateOfferingLifecycleResponse {
  return { DebugInformation: undefined };
}

export const UpdateOfferingLifecycleResponse = {
  encode(message: UpdateOfferingLifecycleResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.DebugInformation !== undefined) {
      Struct.encode(Struct.wrap(message.DebugInformation), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateOfferingLifecycleResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOfferingLifecycleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.DebugInformation = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOfferingLifecycleResponse {
    return { DebugInformation: isObject(object.DebugInformation) ? object.DebugInformation : undefined };
  },

  toJSON(message: UpdateOfferingLifecycleResponse): unknown {
    const obj: any = {};
    if (message.DebugInformation !== undefined) {
      obj.DebugInformation = message.DebugInformation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOfferingLifecycleResponse>, I>>(base?: I): UpdateOfferingLifecycleResponse {
    return UpdateOfferingLifecycleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateOfferingLifecycleResponse>, I>>(
    object: I,
  ): UpdateOfferingLifecycleResponse {
    const message = createBaseUpdateOfferingLifecycleResponse();
    message.DebugInformation = object.DebugInformation ?? undefined;
    return message;
  },
};

function createBaseCreateComputeToDataRequest(): CreateComputeToDataRequest {
  return { did: "", algorithm: "" };
}

export const CreateComputeToDataRequest = {
  encode(message: CreateComputeToDataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.did !== "") {
      writer.uint32(10).string(message.did);
    }
    if (message.algorithm !== "") {
      writer.uint32(18).string(message.algorithm);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateComputeToDataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateComputeToDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.did = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.algorithm = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateComputeToDataRequest {
    return {
      did: isSet(object.did) ? globalThis.String(object.did) : "",
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
    };
  },

  toJSON(message: CreateComputeToDataRequest): unknown {
    const obj: any = {};
    if (message.did !== "") {
      obj.did = message.did;
    }
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateComputeToDataRequest>, I>>(base?: I): CreateComputeToDataRequest {
    return CreateComputeToDataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateComputeToDataRequest>, I>>(object: I): CreateComputeToDataRequest {
    const message = createBaseCreateComputeToDataRequest();
    message.did = object.did ?? "";
    message.algorithm = object.algorithm ?? "";
    return message;
  },
};

function createBaseComputeToDataResponse(): ComputeToDataResponse {
  return { jobId: [] };
}

export const ComputeToDataResponse = {
  encode(message: ComputeToDataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.jobId) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ComputeToDataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeToDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jobId.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeToDataResponse {
    return { jobId: globalThis.Array.isArray(object?.jobId) ? object.jobId.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: ComputeToDataResponse): unknown {
    const obj: any = {};
    if (message.jobId?.length) {
      obj.jobId = message.jobId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComputeToDataResponse>, I>>(base?: I): ComputeToDataResponse {
    return ComputeToDataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComputeToDataResponse>, I>>(object: I): ComputeToDataResponse {
    const message = createBaseComputeToDataResponse();
    message.jobId = object.jobId?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetOfferingRequest(): GetOfferingRequest {
  return { did: "" };
}

export const GetOfferingRequest = {
  encode(message: GetOfferingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.did !== "") {
      writer.uint32(10).string(message.did);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOfferingRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOfferingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.did = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOfferingRequest {
    return { did: isSet(object.did) ? globalThis.String(object.did) : "" };
  },

  toJSON(message: GetOfferingRequest): unknown {
    const obj: any = {};
    if (message.did !== "") {
      obj.did = message.did;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOfferingRequest>, I>>(base?: I): GetOfferingRequest {
    return GetOfferingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOfferingRequest>, I>>(object: I): GetOfferingRequest {
    const message = createBaseGetOfferingRequest();
    message.did = object.did ?? "";
    return message;
  },
};

function createBaseGetOfferingResponse(): GetOfferingResponse {
  return { did: "" };
}

export const GetOfferingResponse = {
  encode(message: GetOfferingResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.did !== "") {
      writer.uint32(10).string(message.did);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOfferingResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOfferingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.did = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOfferingResponse {
    return { did: isSet(object.did) ? globalThis.String(object.did) : "" };
  },

  toJSON(message: GetOfferingResponse): unknown {
    const obj: any = {};
    if (message.did !== "") {
      obj.did = message.did;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOfferingResponse>, I>>(base?: I): GetOfferingResponse {
    return GetOfferingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOfferingResponse>, I>>(object: I): GetOfferingResponse {
    const message = createBaseGetOfferingResponse();
    message.did = object.did ?? "";
    return message;
  },
};

export interface serviceofferingPublisher {
  CreateOffering(request: CreateOfferingRequest): Promise<CreateOfferingResponse>;
  UpdateOffering(request: UpdateOfferingRequest): Promise<UpdateOfferingResponse>;
  UpdateOfferingLifecycle(request: UpdateOfferingLifecycleRequest): Promise<UpdateOfferingLifecycleResponse>;
  RunComputeToData(request: CreateComputeToDataRequest): Promise<ComputeToDataResponse>;
  GetOffering(request: GetOfferingRequest): Promise<GetOfferingResponse>;
}

export const serviceofferingPublisherServiceName = "eupg.serviceofferingpublisher.serviceofferingPublisher";
export class serviceofferingPublisherClientImpl implements serviceofferingPublisher {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || serviceofferingPublisherServiceName;
    this.rpc = rpc;
    this.CreateOffering = this.CreateOffering.bind(this);
    this.UpdateOffering = this.UpdateOffering.bind(this);
    this.UpdateOfferingLifecycle = this.UpdateOfferingLifecycle.bind(this);
    this.RunComputeToData = this.RunComputeToData.bind(this);
    this.GetOffering = this.GetOffering.bind(this);
  }
  CreateOffering(request: CreateOfferingRequest): Promise<CreateOfferingResponse> {
    const data = CreateOfferingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOffering", data);
    return promise.then((data) => CreateOfferingResponse.decode(_m0.Reader.create(data)));
  }

  UpdateOffering(request: UpdateOfferingRequest): Promise<UpdateOfferingResponse> {
    const data = UpdateOfferingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateOffering", data);
    return promise.then((data) => UpdateOfferingResponse.decode(_m0.Reader.create(data)));
  }

  UpdateOfferingLifecycle(request: UpdateOfferingLifecycleRequest): Promise<UpdateOfferingLifecycleResponse> {
    const data = UpdateOfferingLifecycleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateOfferingLifecycle", data);
    return promise.then((data) => UpdateOfferingLifecycleResponse.decode(_m0.Reader.create(data)));
  }

  RunComputeToData(request: CreateComputeToDataRequest): Promise<ComputeToDataResponse> {
    const data = CreateComputeToDataRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RunComputeToData", data);
    return promise.then((data) => ComputeToDataResponse.decode(_m0.Reader.create(data)));
  }

  GetOffering(request: GetOfferingRequest): Promise<GetOfferingResponse> {
    const data = GetOfferingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOffering", data);
    return promise.then((data) => GetOfferingResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
